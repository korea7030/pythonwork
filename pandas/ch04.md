
# numpy 기초 : 배열과 벡터 연산


```python
from numpy.random import randn
import numpy as np
% matplotlib inline
```


```python
# 도움말
np.info(np.ndarray.dtype)
```

    Data-type of the array's elements.
    
    Parameters
    ----------
    None
    
    Returns
    -------
    d : numpy dtype object
    
    See Also
    --------
    numpy.dtype
    
    Examples
    --------
    >>> x
    array([[0, 1],
           [2, 3]])
    >>> x.dtype
    dtype('int32')
    >>> type(x.dtype)
    <type 'numpy.dtype'>


## 4.1 Numpy ndarray : 다차원 배열 객체


```python
data = randn(2,3)
data
```




    array([[-0.76526121,  0.58016404, -1.18678286],
           [-2.11241904,  0.41522432, -2.13738022]])



- data 계산


```python
print('data * 10 : ', data * 10); print('data+data : ', data+data);
```

    data * 10 :  [[ -7.65261212   5.80164043 -11.86782857]
     [-21.12419039   4.15224323 -21.37380217]]
    data+data :  [[-1.53052242  1.16032809 -2.37356571]
     [-4.22483808  0.83044865 -4.27476043]]


- ndarray는 같은 데이터를 담아야 함.
- 모든 배열은 크기를 알려주는 shape와 저장된 자료형을 알려주는 dtype이라는 객체가 있음.


```python
data.shape # 크기
```




    (2, 3)




```python
data.dtype # 자료형
```




    dtype('float64')



### 4.1.1 ndarray 생성
참고 : https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.array-creation.html


```python
data1 = [6, 7.5, 8, 0, 1]

arr1 = np.array(data1)
arr1
```




    array([ 6. ,  7.5,  8. ,  0. ,  1. ])




```python
data2 = [[1,2,3,4], [5,6,7,8]]

arr2 = np.array(data2)
arr2
```




    array([[1, 2, 3, 4],
           [5, 6, 7, 8]])




```python
arr2.ndim # 행 크기
```




    2




```python
arr2.shape
```




    (2, 4)



- 배열 생성 함수 : zeros, ones, empty


```python
np.zeros(10)
```




    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])




```python
np.ones(10)
```




    array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])



##### np.empty
Parameters:	
- shape : int or tuple of int

- Shape of the empty array

- dtype : data-type, optional

- order : {‘C’, ‘F’}, optional

  Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.

Returns:	
- out : ndarray

  Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.


```python
np.empty((3,2)) # default : row 방향으로 먼저 채움
```




    array([[ 1.53052242,  4.22483808],
           [ 1.16032809,  0.83044865],
           [ 2.37356571,  4.27476043]])




```python
np.empty((3,2), order='F') # column 방향으로 먼저 채움
```




    array([[ 1.53052242,  0.83044865],
           [ 4.22483808,  2.37356571],
           [ 1.16032809,  4.27476043]])




```python
np.empty((2,3,2)) # 초기화되지 않는 배열 생성(tuple형태로 넘겨줌, list도 됨) x(row),y(col),z(depth)
```




    array([[[  2.31584178e+077,  -1.49457841e-154],
            [  3.45845952e-323,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000]],
    
           [[  0.00000000e+000,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000]]])



### 4.1.1-1) 데이터 생성 함수

###### np.linspace 함수
- numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
- start부터 stop의 범위에서 num개를 균일한 간격으로 데이터를 생성하고 배열을 만드는 함수
- 요소 개수를 기준으로 균등 간격의 배열을 생성


```python
arr = np.linspace(0,1,5)
arr
```




    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])




```python
import matplotlib.pyplot as plt
plt.plot(arr,'o')
plt.show()
```


![png](ch04_files/ch04_25_0.png)


###### np.arange 함수
- numpy.arange([start,] stop[, step,], dtype=None)
- start부터 stop 미만까지 step 간격으로 데이터 생성한 후 배열을 만듦
- 범위내에서 간격을 기준 균등 간격의 배열
- 요소의 개수가 아닌 데이터의 간격을 기준으로 배열 생성


```python
arr = np.arange(0,10,2, np.float)
arr
```




    array([ 0.,  2.,  4.,  6.,  8.])




```python
# arange의 데이터 추출 시각화
import matplotlib.pyplot as plt
plt.plot(arr, 'o')
plt.show()
```


![png](ch04_files/ch04_28_0.png)


###### np.logspace 함수
- numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)
- 로그 스케일의 linspace 함수
- 로그 스케일로 지정된 범위에서 num 개수만큼 균등 간격으로 데이터 생성한 후 배열 만듦


```python
arr = np.logspace(0.1, 1, 20, endpoint=True)
arr
```




    array([  1.25892541,   1.40400425,   1.565802  ,   1.74624535,
             1.94748304,   2.1719114 ,   2.42220294,   2.70133812,
             3.0126409 ,   3.35981829,   3.74700446,   4.17881006,
             4.66037703,   5.19743987,   5.79639395,   6.46437163,
             7.2093272 ,   8.04013161,   8.9666781 ,  10.        ])




```python
# logspace의 데이터 추출 시각화
import matplotlib.pyplot as plt
plt.plot(arr, 'o')
plt.show()
```


![png](ch04_files/ch04_31_0.png)


### 4.1.2 ndarray 자료형


```python
arr1 = np.array([1,2,3], dtype=np.float64)
arr2 = np.array([1,2,3], dtype=np.int32)
```


```python
arr2
```




    array([1, 2, 3], dtype=int32)



- type 변경


```python
arr = np.array([1,2,3,4,5])
float_arr = arr.astype(np.float64)

float_arr.dtype
```




    dtype('float64')




```python
numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
numeric_strings.astype(float)
```




    array([  1.25,  -9.6 ,  42.  ])



** astype의 경우 array를 새로 생성한다.
- 참고 : https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html

### 4.1.3 배열과 스칼라의 연산


```python
arr = np.array([[1.,2.,3.], [4.,5.,6.]])
```


```python
arr * arr
```




    array([[  1.,   4.,   9.],
           [ 16.,  25.,  36.]])




```python
arr - arr
```




    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])




```python
1/ arr
```




    array([[ 1.        ,  0.5       ,  0.33333333],
           [ 0.25      ,  0.2       ,  0.16666667]])



### 4.1.4 색인과 슬라이싱 기초


```python
arr = np.arange(10)
arr[5:8]
```




    array([5, 6, 7])




```python
arr[5:8] = 12
```


```python
arr
```




    array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])



** 배열조각(slice)의 경우 데이터가 복사되지 않고 원본 배열의 view역할을 한다.


```python
arr_slice = arr[5:8] # 변수는 새로 생성됐으나, 원본 데이터를 바라봄

arr_slice[1] = 12345
print('12345 위치 확인 : ', arr)
```

    12345 위치 확인 :  [    0     1     2     3     4    12 12345    12     8     9]



```python
arr_slice[:] = 64 # 처음부터 끝까지
print(arr)
```

    [ 0  1  2  3  4 64 64 64  8  9]



```python
arr_slice2 = arr[5:8].copy() # 명시적인 array 복제
```


```python
arr_slice2[1] = 12345
```


```python
arr
```




    array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])



- 3차원 배열


```python
arr3d = np.array([[[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]]])
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0]
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
old_values = arr3d[0].copy()
```


```python
arr3d[0] = 42
```


```python
arr3d
```




    array([[[42, 42, 42],
            [42, 42, 42]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0] = old_values
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])



##### 슬라이스 색인(N차원 배열)


```python
arr[1:6]
```




    array([ 1,  2,  3,  4, 64])




```python
arr2d = np.array([[1,2,3], [4,5,6], [7,8,9]])
```


```python
arr2d[:2] # column list slice
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
arr2d[:2,1:] # column list slice, row list slice
```




    array([[2, 3],
           [5, 6]])



### 4.1.5 불리언 색인


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np.random.randn(7,4)
```


```python
data
```




    array([[ 0.25129612, -0.69758146,  1.00727644,  0.9071042 ],
           [ 2.0684704 ,  0.82290603,  0.5915462 ,  0.99175753],
           [-0.96614986,  0.49556827, -0.41331362, -0.30585589],
           [ 0.93312556,  0.17098154, -1.36144341, -0.04100926],
           [ 0.9529966 ,  1.1370512 ,  0.90295082,  3.22249049],
           [-0.90127344,  1.32255837,  0.6131161 , -0.27984788],
           [ 0.44365473, -0.36811058, -0.9023568 ,  0.12763459]])




```python
names == 'Bob'
```




    array([ True, False, False,  True, False, False, False], dtype=bool)




```python
data[names == 'Bob'] # column list의 0,3번째 값들 반환
```




    array([[ 0.25129612, -0.69758146,  1.00727644,  0.9071042 ],
           [ 0.93312556,  0.17098154, -1.36144341, -0.04100926]])




```python
data[~(names == 'Bob')] # 1.13 ver 이전은 '-'로 negative 선택
```




    array([[ 2.0684704 ,  0.82290603,  0.5915462 ,  0.99175753],
           [-0.96614986,  0.49556827, -0.41331362, -0.30585589],
           [ 0.9529966 ,  1.1370512 ,  0.90295082,  3.22249049],
           [-0.90127344,  1.32255837,  0.6131161 , -0.27984788],
           [ 0.44365473, -0.36811058, -0.9023568 ,  0.12763459]])




```python
mask = (names == 'Bob') | (names == 'Will') # OR조건
```


```python
print(mask)
data[mask]
```

    [ True False  True  True  True False False]





    array([[ 0.25129612, -0.69758146,  1.00727644,  0.9071042 ],
           [-0.96614986,  0.49556827, -0.41331362, -0.30585589],
           [ 0.93312556,  0.17098154, -1.36144341, -0.04100926],
           [ 0.9529966 ,  1.1370512 ,  0.90295082,  3.22249049]])




```python
data[data < 0] = 0
```


```python
data
```




    array([[ 0.25129612,  0.        ,  1.00727644,  0.9071042 ],
           [ 2.0684704 ,  0.82290603,  0.5915462 ,  0.99175753],
           [ 0.        ,  0.49556827,  0.        ,  0.        ],
           [ 0.93312556,  0.17098154,  0.        ,  0.        ],
           [ 0.9529966 ,  1.1370512 ,  0.90295082,  3.22249049],
           [ 0.        ,  1.32255837,  0.6131161 ,  0.        ],
           [ 0.44365473,  0.        ,  0.        ,  0.12763459]])



### 4.1.6 팬시색인(정수 배열을 사용한 색인)
- 선택된 데이터를 새로운 배열로 복사


```python
arr = np.empty((8,4))

for i in range(8):
    arr[i] = i
```


```python
arr
```




    array([[ 0.,  0.,  0.,  0.],
           [ 1.,  1.,  1.,  1.],
           [ 2.,  2.,  2.,  2.],
           [ 3.,  3.,  3.,  3.],
           [ 4.,  4.,  4.,  4.],
           [ 5.,  5.,  5.,  5.],
           [ 6.,  6.,  6.,  6.],
           [ 7.,  7.,  7.,  7.]])




```python
arr[[4,3,0,6]]
```




    array([[ 4.,  4.,  4.,  4.],
           [ 3.,  3.,  3.,  3.],
           [ 0.,  0.,  0.,  0.],
           [ 6.,  6.,  6.,  6.]])




```python
arr[[-3,-5,-7]] # 끝에서부터 색인
```




    array([[ 5.,  5.,  5.,  5.],
           [ 3.,  3.,  3.,  3.],
           [ 1.,  1.,  1.,  1.]])




```python
arr2d = np.arange(32).reshape((8,4))
arr2d
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15],
           [16, 17, 18, 19],
           [20, 21, 22, 23],
           [24, 25, 26, 27],
           [28, 29, 30, 31]])




```python
arr2d[[1,5,7,2]]
```




    array([[ 4,  5,  6,  7],
           [20, 21, 22, 23],
           [28, 29, 30, 31],
           [ 8,  9, 10, 11]])




```python
arr2d[[1,5,7,2], [0,3,1,2]] # (1,0), (5,3), (7,1), (2,2)
```




    array([ 4, 23, 29, 10])




```python
arr2d[[1,5,7,2]][:,[0,3,1,2]] 
# [(1,0), (1,3), (1,1), (1,2)
#  (5,0), (5,3), (5,1), (5,2)
#  (7,0), (7,3), (7,1), (7,2)
#  (2,0), (2,3), (2,1), (2,2)]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])




```python
arr2d[np.ix_([1,5,7,2], [0,3,1,2])]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])



### 4.1.7 배열 전체와 축 바꾸기


```python
arr = np.arange(15).reshape((3,5))
```


```python
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
arr.T
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])




```python
arr = np.random.rand(6,3)
print(np.dot(arr.T, arr))
```

    [[ 1.3411573   1.75731877  1.58656298]
     [ 1.75731877  2.52847933  2.15823587]
     [ 1.58656298  2.15823587  2.18726589]]


- 다차원 축 치환(transpose)


```python
arr = np.arange(16).reshape((2,2,4))
arr
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr.transpose((1,0,2))
```




    array([[[ 0,  1,  2,  3],
            [ 8,  9, 10, 11]],
    
           [[ 4,  5,  6,  7],
            [12, 13, 14, 15]]])



## 4.2 유니버셜 함수
- array의 원소별로 연산 수행


```python
arr = np.arange(10)
```


```python
np.sqrt(arr)
```




    array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
            2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])




```python
np.exp(arr)
```




    array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
             2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
             4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
             8.10308393e+03])



- 이항 유니버셜


```python
x = randn(8)
y = randn(8)
```


```python
x
```




    array([ 0.96079846, -0.55948542,  1.23017455, -0.78072623,  1.59146255,
            1.26319269, -0.60622248, -1.16865283])




```python
y
```




    array([-0.65269222,  1.24198893, -0.18190911, -0.82198584, -0.38792926,
            1.37284049,  0.84112496, -0.97820149])




```python
np.maximum(x,y) # element-wise maximum
```




    array([ 0.96079846,  1.24198893,  1.23017455, -0.78072623,  1.59146255,
            1.37284049,  0.84112496, -0.97820149])




```python
arr = randn(7) * 5
```


```python
np.modf(arr) # 몫과 나머지를 같이 반환
```




    (array([-0.68511791,  0.30928489, -0.8469372 ,  0.00667382,  0.53850292,
            -0.74620348, -0.29603339]), array([-1.,  1., -2.,  2.,  3., -2., -6.]))



## 4.3 배열을 사용한 데이터 처리


```python
points = np.arange(-3,3, 0.02) # 300 points
```


```python
len(points)
```




    300




```python
points
```




    array([ -3.00000000e+00,  -2.98000000e+00,  -2.96000000e+00,
            -2.94000000e+00,  -2.92000000e+00,  -2.90000000e+00,
            -2.88000000e+00,  -2.86000000e+00,  -2.84000000e+00,
            -2.82000000e+00,  -2.80000000e+00,  -2.78000000e+00,
            -2.76000000e+00,  -2.74000000e+00,  -2.72000000e+00,
            -2.70000000e+00,  -2.68000000e+00,  -2.66000000e+00,
            -2.64000000e+00,  -2.62000000e+00,  -2.60000000e+00,
            -2.58000000e+00,  -2.56000000e+00,  -2.54000000e+00,
            -2.52000000e+00,  -2.50000000e+00,  -2.48000000e+00,
            -2.46000000e+00,  -2.44000000e+00,  -2.42000000e+00,
            -2.40000000e+00,  -2.38000000e+00,  -2.36000000e+00,
            -2.34000000e+00,  -2.32000000e+00,  -2.30000000e+00,
            -2.28000000e+00,  -2.26000000e+00,  -2.24000000e+00,
            -2.22000000e+00,  -2.20000000e+00,  -2.18000000e+00,
            -2.16000000e+00,  -2.14000000e+00,  -2.12000000e+00,
            -2.10000000e+00,  -2.08000000e+00,  -2.06000000e+00,
            -2.04000000e+00,  -2.02000000e+00,  -2.00000000e+00,
            -1.98000000e+00,  -1.96000000e+00,  -1.94000000e+00,
            -1.92000000e+00,  -1.90000000e+00,  -1.88000000e+00,
            -1.86000000e+00,  -1.84000000e+00,  -1.82000000e+00,
            -1.80000000e+00,  -1.78000000e+00,  -1.76000000e+00,
            -1.74000000e+00,  -1.72000000e+00,  -1.70000000e+00,
            -1.68000000e+00,  -1.66000000e+00,  -1.64000000e+00,
            -1.62000000e+00,  -1.60000000e+00,  -1.58000000e+00,
            -1.56000000e+00,  -1.54000000e+00,  -1.52000000e+00,
            -1.50000000e+00,  -1.48000000e+00,  -1.46000000e+00,
            -1.44000000e+00,  -1.42000000e+00,  -1.40000000e+00,
            -1.38000000e+00,  -1.36000000e+00,  -1.34000000e+00,
            -1.32000000e+00,  -1.30000000e+00,  -1.28000000e+00,
            -1.26000000e+00,  -1.24000000e+00,  -1.22000000e+00,
            -1.20000000e+00,  -1.18000000e+00,  -1.16000000e+00,
            -1.14000000e+00,  -1.12000000e+00,  -1.10000000e+00,
            -1.08000000e+00,  -1.06000000e+00,  -1.04000000e+00,
            -1.02000000e+00,  -1.00000000e+00,  -9.80000000e-01,
            -9.60000000e-01,  -9.40000000e-01,  -9.20000000e-01,
            -9.00000000e-01,  -8.80000000e-01,  -8.60000000e-01,
            -8.40000000e-01,  -8.20000000e-01,  -8.00000000e-01,
            -7.80000000e-01,  -7.60000000e-01,  -7.40000000e-01,
            -7.20000000e-01,  -7.00000000e-01,  -6.80000000e-01,
            -6.60000000e-01,  -6.40000000e-01,  -6.20000000e-01,
            -6.00000000e-01,  -5.80000000e-01,  -5.60000000e-01,
            -5.40000000e-01,  -5.20000000e-01,  -5.00000000e-01,
            -4.80000000e-01,  -4.60000000e-01,  -4.40000000e-01,
            -4.20000000e-01,  -4.00000000e-01,  -3.80000000e-01,
            -3.60000000e-01,  -3.40000000e-01,  -3.20000000e-01,
            -3.00000000e-01,  -2.80000000e-01,  -2.60000000e-01,
            -2.40000000e-01,  -2.20000000e-01,  -2.00000000e-01,
            -1.80000000e-01,  -1.60000000e-01,  -1.40000000e-01,
            -1.20000000e-01,  -1.00000000e-01,  -8.00000000e-02,
            -6.00000000e-02,  -4.00000000e-02,  -2.00000000e-02,
             2.66453526e-15,   2.00000000e-02,   4.00000000e-02,
             6.00000000e-02,   8.00000000e-02,   1.00000000e-01,
             1.20000000e-01,   1.40000000e-01,   1.60000000e-01,
             1.80000000e-01,   2.00000000e-01,   2.20000000e-01,
             2.40000000e-01,   2.60000000e-01,   2.80000000e-01,
             3.00000000e-01,   3.20000000e-01,   3.40000000e-01,
             3.60000000e-01,   3.80000000e-01,   4.00000000e-01,
             4.20000000e-01,   4.40000000e-01,   4.60000000e-01,
             4.80000000e-01,   5.00000000e-01,   5.20000000e-01,
             5.40000000e-01,   5.60000000e-01,   5.80000000e-01,
             6.00000000e-01,   6.20000000e-01,   6.40000000e-01,
             6.60000000e-01,   6.80000000e-01,   7.00000000e-01,
             7.20000000e-01,   7.40000000e-01,   7.60000000e-01,
             7.80000000e-01,   8.00000000e-01,   8.20000000e-01,
             8.40000000e-01,   8.60000000e-01,   8.80000000e-01,
             9.00000000e-01,   9.20000000e-01,   9.40000000e-01,
             9.60000000e-01,   9.80000000e-01,   1.00000000e+00,
             1.02000000e+00,   1.04000000e+00,   1.06000000e+00,
             1.08000000e+00,   1.10000000e+00,   1.12000000e+00,
             1.14000000e+00,   1.16000000e+00,   1.18000000e+00,
             1.20000000e+00,   1.22000000e+00,   1.24000000e+00,
             1.26000000e+00,   1.28000000e+00,   1.30000000e+00,
             1.32000000e+00,   1.34000000e+00,   1.36000000e+00,
             1.38000000e+00,   1.40000000e+00,   1.42000000e+00,
             1.44000000e+00,   1.46000000e+00,   1.48000000e+00,
             1.50000000e+00,   1.52000000e+00,   1.54000000e+00,
             1.56000000e+00,   1.58000000e+00,   1.60000000e+00,
             1.62000000e+00,   1.64000000e+00,   1.66000000e+00,
             1.68000000e+00,   1.70000000e+00,   1.72000000e+00,
             1.74000000e+00,   1.76000000e+00,   1.78000000e+00,
             1.80000000e+00,   1.82000000e+00,   1.84000000e+00,
             1.86000000e+00,   1.88000000e+00,   1.90000000e+00,
             1.92000000e+00,   1.94000000e+00,   1.96000000e+00,
             1.98000000e+00,   2.00000000e+00,   2.02000000e+00,
             2.04000000e+00,   2.06000000e+00,   2.08000000e+00,
             2.10000000e+00,   2.12000000e+00,   2.14000000e+00,
             2.16000000e+00,   2.18000000e+00,   2.20000000e+00,
             2.22000000e+00,   2.24000000e+00,   2.26000000e+00,
             2.28000000e+00,   2.30000000e+00,   2.32000000e+00,
             2.34000000e+00,   2.36000000e+00,   2.38000000e+00,
             2.40000000e+00,   2.42000000e+00,   2.44000000e+00,
             2.46000000e+00,   2.48000000e+00,   2.50000000e+00,
             2.52000000e+00,   2.54000000e+00,   2.56000000e+00,
             2.58000000e+00,   2.60000000e+00,   2.62000000e+00,
             2.64000000e+00,   2.66000000e+00,   2.68000000e+00,
             2.70000000e+00,   2.72000000e+00,   2.74000000e+00,
             2.76000000e+00,   2.78000000e+00,   2.80000000e+00,
             2.82000000e+00,   2.84000000e+00,   2.86000000e+00,
             2.88000000e+00,   2.90000000e+00,   2.92000000e+00,
             2.94000000e+00,   2.96000000e+00,   2.98000000e+00])



######  meshgrid
- 1차원 배열 2개를 받아 매칭할 수 있는 (x,y)의 2차원 배열을 2개 반환


```python
xs, ys = np.meshgrid(points, points)
```


```python
ys
```




    array([[-3.  , -3.  , -3.  , ..., -3.  , -3.  , -3.  ],
           [-2.98, -2.98, -2.98, ..., -2.98, -2.98, -2.98],
           [-2.96, -2.96, -2.96, ..., -2.96, -2.96, -2.96],
           ..., 
           [ 2.94,  2.94,  2.94, ...,  2.94,  2.94,  2.94],
           [ 2.96,  2.96,  2.96, ...,  2.96,  2.96,  2.96],
           [ 2.98,  2.98,  2.98, ...,  2.98,  2.98,  2.98]])




```python
import matplotlib.pyplot as plt
```


```python
z = np.sqrt(xs **2, ys**2)
z
```




    array([[ 3.  ,  2.98,  2.96, ...,  2.94,  2.96,  2.98],
           [ 3.  ,  2.98,  2.96, ...,  2.94,  2.96,  2.98],
           [ 3.  ,  2.98,  2.96, ...,  2.94,  2.96,  2.98],
           ..., 
           [ 3.  ,  2.98,  2.96, ...,  2.94,  2.96,  2.98],
           [ 3.  ,  2.98,  2.96, ...,  2.94,  2.96,  2.98],
           [ 3.  ,  2.98,  2.96, ...,  2.94,  2.96,  2.98]])




```python
plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values"); plt.imshow(z, cmap=plt.cm.gray);plt.colorbar();
```


![png](ch04_files/ch04_114_0.png)


### 4.3.1 배열연산으로 조건절 표현

###### np.where
- x if 조건 else y 같은 삼항식의 벡터화 버전


```python
xarr = np.array([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array([True, False, True, True, False])
```


```python
# 순수 python 처리
import time
start_time = time.time()
result = [(x if c else y) for x,y,c in zip(xarr, yarr, cond)]
end_time = time.time()
print(end_time-start_time)
```

    7.82012939453125e-05



```python
# np.where 처리
start_time = time.time()
result = np.where(cond, xarr, yarr)
end_time = time.time()
print(end_time-start_time)
```

    5.817413330078125e-05



```python
arr = np.random.randn(4,4)
arr
```




    array([[-1.98302123,  2.04147473,  0.82562767, -0.54557937],
           [-0.75246713,  0.76656267, -0.65855843,  0.10925724],
           [ 0.13178638, -2.06140712,  0.22070199, -0.87181551],
           [ 0.46261327, -0.23387717, -0.80032102,  0.09104055]])




```python
np.where(arr>0, 2,-2)
```




    array([[-2,  2,  2, -2],
           [-2,  2, -2,  2],
           [ 2, -2,  2, -2],
           [ 2, -2, -2,  2]])




```python
np.where(arr > 0, 2, arr)
```




    array([[-1.98302123,  2.        ,  2.        , -0.54557937],
           [-0.75246713,  2.        , -0.65855843,  2.        ],
           [ 2.        , -2.06140712,  2.        , -0.87181551],
           [ 2.        , -0.23387717, -0.80032102,  2.        ]])



### 4.3.2 수학 메서드와 통계 메서드


```python
arr = randn(5,4) # normally-distributed data
```


```python
arr
```




    array([[-1.31223884, -1.15028346, -1.60798522,  1.74426468],
           [ 0.07349061,  0.44927717,  0.8526916 ,  0.36417954],
           [ 0.4631917 , -1.21660627,  0.82372768,  1.4799884 ],
           [ 0.20229186, -1.56632841,  0.54960312, -0.54517541],
           [-0.70172858,  1.00670282,  0.72926204, -0.06967852]])




```python
arr.mean()
```




    0.028432324988118506




```python
np.mean(arr)
```




    0.028432324988118506



참고 : http://taewan.kim/post/numpy_sum_axis/
- 0의 경우 column방향으로 바라보고 아래로 계산
- 1의 경우 row방향으로 바라보고 아래로 계산
- 2의 경우 depth(z축)방향으로 바라보고 아래로 계산


```python
arr.mean(axis=0) # axis=0 : column / axis=1 : row
```




    array([-0.25499865, -0.49544763,  0.26945984,  0.59471574])




```python
arr = np.array([[0,1,2], [3,4,5], [6,7,8]])
```


```python
arr.cumsum(1)
```




    array([[ 0,  1,  3],
           [ 3,  7, 12],
           [ 6, 13, 21]])




```python
arr.cumprod(1)
```




    array([[  0,   0,   0],
           [  3,  12,  60],
           [  6,  42, 336]])



### 4.3.3 boolean 배열을 위한 메서드


```python
arr = randn(100)
```


```python
(arr > 0).sum()
```




    59




```python
bools = np.array([False, False, True, False])
```


```python
# any : 하나이상의 값이 True 인지 확인
bools.any()
```




    True




```python
# all : 모든 원소값이 True 인지 확인
bools.all()
```




    False



### 4.3.4 정렬


```python
arr = randn(8)
arr
```




    array([ 0.62202312, -0.08181695, -2.09196955,  1.31124257, -0.5009629 ,
            0.34664576,  1.35479345, -0.27282668])




```python
arr.sort()
```


```python
arr
```




    array([-2.09196955, -0.5009629 , -0.27282668, -0.08181695,  0.34664576,
            0.62202312,  1.31124257,  1.35479345])



- 다차원배열


```python
arr = randn(5,3)
arr
```




    array([[ 1.58392103,  1.0070078 , -0.16934418],
           [ 0.2630918 ,  1.00769366, -0.93037024],
           [-0.97563311, -1.33799973,  1.26497828],
           [-1.15758724, -0.37291993, -0.26878073],
           [ 0.47255055,  0.00677721, -0.44073018]])




```python
arr.sort(0) # 0 : column, 1: row
```


```python
arr
```




    array([[-1.15758724, -1.33799973, -0.93037024],
           [-0.97563311, -0.37291993, -0.44073018],
           [ 0.2630918 ,  0.00677721, -0.26878073],
           [ 0.47255055,  1.0070078 , -0.16934418],
           [ 1.58392103,  1.00769366,  1.26497828]])




```python
# 분위수 구하기(ex)
large_arr = randn(1000)
large_arr.sort()
large_arr[int(0.05 * len(large_arr))]
```




    -1.5452536434233857



### 4.3.5 집합함수
참고 : https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.set.html


```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names)
```




    array(['Bob', 'Joe', 'Will'],
          dtype='<U4')




```python
# 순수 python
sorted(set(names))
```




    ['Bob', 'Joe', 'Will']




```python
# np.in1d : 2개의 배열을 받아, 앞의 배열의 각 원소가 두번째 배열의 원소를 포함하는지 boolean값 반환
values = np.array([6,0,0,3,2,5,6])
np.in1d(values, [2,3,6])
```




    array([ True, False, False,  True,  True, False,  True], dtype=bool)



## 4.4 배열의 파일 입/출력

### 4.4.1 배열을 바이너리 형식으로 디스크에 저장


```python
arr = np.arange(10)
np.save('some_array', arr) # 확장자가 없을 경우 기본적으로 npy
```


```python
np.load('some_array.npy')
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.savez('array_archive.npz', a=arr, b=arr) # 여러 배열을 압축저장
```


```python
arch = np.load('array_archive.npz')
arch['b']
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



### 4.4.2 텍스트 파일 불러오기와 저장하기


```python
arr = np.loadtxt('./ch04/array_ex.txt', delimiter=',')
```


```python
arr
```




    array([[ 0.580052,  0.18673 ,  1.040717,  1.134411],
           [ 0.194163, -0.636917, -0.938659,  0.124094],
           [-0.12641 ,  0.268607, -0.695724,  0.047428],
           [-1.484413,  0.004176, -0.744203,  0.005487],
           [ 2.302869,  0.200131,  1.670238, -1.88109 ],
           [-0.19323 ,  1.047233,  0.482803,  0.960334]])



## 4.5 선형대수
참고 : https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.linalg.html


```python
x = np.array([[1., 2., 3.], [4., 5., 6.]])
y = np.array([[6., 23.], [-1, 7], [8,9]])
```


```python
x
```




    array([[ 1.,  2.,  3.],
           [ 4.,  5.,  6.]])




```python
y
```




    array([[  6.,  23.],
           [ -1.,   7.],
           [  8.,   9.]])




```python
np.dot(x, np.ones(3))
```




    array([  6.,  15.])




```python
np.random.seed(12345)
```


```python
# numpy.linalg : 행렬 분할과 역행렬, 행렬식 등을 포함
from numpy.linalg import inv, qr
X = randn(5, 5)
mat = X.T.dot(X)
inv(mat)
mat.dot(inv(mat))
q, r = qr(mat)
r
```




    array([[ -6.92714002,   7.38899524,   6.12272905,  -7.11625341,
             -4.92150833],
           [  0.        ,  -3.97347612,  -0.86707993,   2.97472904,
             -5.74024113],
           [  0.        ,   0.        , -10.26810228,   1.89090298,
              1.60790112],
           [  0.        ,   0.        ,   0.        ,  -1.29964934,
              3.35772244],
           [  0.        ,   0.        ,   0.        ,   0.        ,
              0.55705805]])



## 4.6 난수 생성
참고 : https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.random.html


```python
samples = np.random.normal(size=(4,4))
```


```python
samples
```




    array([[  1.24121276e-01,   3.02613562e-01,   5.23772068e-01,
              9.40277775e-04],
           [  1.34380979e+00,  -7.13543985e-01,  -8.31153539e-01,
             -2.37023165e+00],
           [ -1.86076079e+00,  -8.60757398e-01,   5.60145293e-01,
             -1.26593449e+00],
           [  1.19827125e-01,  -1.06351245e+00,   3.32882716e-01,
             -2.35941881e+00]])




```python
# python 내장 random : 한번에 하나의 값만 생성
from random import normalvariate
N = 100000
%timeit samples = [normalvariate(0,1) for _ in range(N)]
```

    64 ms ± 2.68 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)



```python
%timeit np.random.normal(size=N)
```

    2.99 ms ± 26.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)


## 4.7 계단오르기 예제


```python
import random
position = 0
walk = [position]
steps = 1000
for i in range(steps):
    step = 1 if random.randint(0,1) else -1
    position += step
    walk.append(position)
```


```python
nsteps = 1000
draws = np.random.randint(0,2,size=nsteps)
steps = np.where(draws > 0, 1, -1)
walk = steps.cumsum()
```


```python
print(walk.min()); print(walk.max());
```

    -25
    27


### 4.7.1 한 번에 계단 오르내리기 시뮬레이션


```python
nwalks = 5000
nsteps = 1000
draws = np.random.randint(0,2,size=(nwalks, nsteps)) # 0 or 1
steps = np.where(draws > 0, 1, -1)
walks = steps.cumsum(1)
walks
```




    array([[  1,   0,   1, ...,  70,  71,  72],
           [  1,   0,  -1, ..., -12, -13, -12],
           [  1,   0,   1, ...,  -4,  -5,  -6],
           ..., 
           [ -1,  -2,  -1, ...,  26,  27,  28],
           [ -1,  -2,  -1, ...,  22,  21,  22],
           [  1,   2,   3, ..., -22, -23, -24]])



누적합이 30 혹은 -30이 되는 최초 시점 계산


```python
hits30 = (np.abs(walks)>= 30).any(1)
hits30
```




    array([ True,  True,  True, ...,  True,  True,  True], dtype=bool)




```python
hits30.sum()
```




    3399




```python
# 처음 위치에서 30칸 이상 멀어지는 최소횟수
crossing_times = (np.abs(walks[hits30]) > 30).argmax()
crossing_times
```




    342


